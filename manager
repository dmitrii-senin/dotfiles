#! /bin/zsh

autoload -Uz colors && colors

prog_name=$(basename $0)
repo_root="${0:A:h}"

function subcmd_help() {
	echo "Usage: ${fg_bold[white]}${prog_name}${reset_color} <subcommand> [options]"
	echo
	echo "SUBCOMMANDS"
	echo "    ${fg_bold[white]}pull${reset_color}      Pull the last dotfiles repo changes"
	echo "    ${fg_bold[white]}deploy${reset_color}   Copy dotfiles to destination directories"
	echo "    ${fg_bold[white]}sync${reset_color}      Sync deployed dotfiles with the repo"
	echo "    ${fg_bold[white]}push${reset_color}      Add and push local dotfiles changes to the repo"
	echo
	echo "DETAILS"
	echo "${fg_bold[white]}deploy${reset_color} <dest-dir>"
	echo "   ${fg_bold[white]}dest-dir${reset_color}"
	echo "        Directory to where the dotfiles will be deployed (default: \$HOME)."
}

function subcmd_pull() {
	git -C "$repo_root" pull > /dev/null 2>&1
	if [ $? -ne 0 ]; then echo "Error: Failed to pull dotfiles repo" && return 1; fi
}

function subcmd_deploy() {
	local dest_root=${1:-$HOME}
	local prefix_black_list=(.git/ README.md LICENSE manager)
	for repo_path in $(find "$repo_root" -type f ); do
		local rel_path="${repo_path##"${repo_root}"/}"
		local in_black_list="no"
		for prefix in $prefix_black_list; do
			if [[ "$rel_path" =~ "^${prefix}*" ]]; then
				local in_black_list="yes"
				break
			fi
		done
		if [ $in_black_list = "no" ]; then
			local dest_path="$dest_root/$rel_path"
			mkdir -p $(dirname "$dest_path") && cp "$repo_path" "$dest_path"
		fi
	done
}

subcommand=$1
case $subcommand in
	"" | "-h" | "--help")
		subcmd_help
		;;

	*)
		shift
		subcmd_${subcommand} $@
		if [ $? = 127 ]; then
			echo "Error: '$subcommand' is not a known subcommand." >&2
			echo "Please run '$prog_name --help' to get a list of supported subcommands." >&2
			exit 1
		fi
		;;
esac
